# alterstack

Проект задуман для создания удобного инстумента для работы с корутинами в C++. Каждая созданная сопрограмма имеет свой стек. В проекте используется boost::context, а именно самая низкоуровневая часть от него, которая непосредственно занимается созданием контекста (нового стека) и переключением между стеками (boost::context::make_fcontext и jump_fcontext). Проект изначально нацелен на получение наилучшего быстродействия при создании и переключении контестов (все остальное делает код пользователя).

# Клонирование и создание проекта

Проект использует git submodule, поэтому его нужно либо клонировать рекурсивно, либо после клонирования обновлять подмодули.
```
git clone --recursive https://github.com/masterspline/alterstack.git 
cd alterstack
mkdir build
cd build
cmake ../
make -j 2
```
в результате будет собрана статическая библиотека libalterstack.a и тесты в папке ./test

Для использования библиотеки в своем коде нужно включить единственный заголовочный файл:
```
#include "alterstack/api.hpp"
```
Сейчас единственный нужный пользователю класс - это alterstack::Task, у которого есть конструктор, принимающий std::function<void()>, деструктор и два публичных метода:
```
Task(::std::function<void()> runnable);

static void yield();
void join();
```
Конструктор сейчас создает задачу с собственным контекстом (стеком). По сути, Task - это поток с кооперативной многозадачностью. Конструктор сразу же запускает задачу на выполнение на том же потоке, из которого ее вызвали, и выполняет ее до тех пор, пока задача сама не передаст управление другой задаче (yield()).

join() - позволяет дождаться завершения задачи (Task). Может быть вызван как из корутины, так и из потока, в котором выполняется main, например. Работает по разному, подробнее в разделе про планирование.

yield - статический метод. Передает управление (уступает поток) другой задаче. Может быть вызван как из корутины, так и из потока, в котором выполняется main, например. Работает по разному, подробнее в разделе про планирование.

В деструкторе ~Task если задаче еще не завершена вызывается Task::join() чтобы дождаться завершения выполнения корутины прежде, чем освободить ее память. Это отличается от поведения std::thread, объект Task не будет удален, пока не его задача не завершится.
```
#include "alterstack/Api.hpp" // API пользователя
#include <iostream>

using alterstack::Task;

void ctx_function()
{
    std::cout << "Context function, first part\n";
    Task::yield();
    std::cout << "Context function, second part\n";
    Task::yield();
    std::cout << "Context function, third part\n";
}
int main()
{
    Task task;
    task.run(ctx_function); // Тут этот же поток выполнит первые две строки функции ctx_function
    Task::yield();          // сюда вернется основной поток после первого yield функции контекста и сразу же 
                            // переключит контекст на первую корутину в очереди на выполнение, т.е. вернется 
                            // обратно и выполнит следующие две строки ctx_function
                            // Также возможен вариант, что после первого yield в ctx_function, корутину 
                            // продолжит выполнять поток или BgRunner (специального пула потоков)
    task::join();           // дальнейшее выполнение кода main будет преостановлено, но поток OS переключится
    // на первую корутину в очереди на выполнение, т.е. вернется обратно и выполнит
    // последние две строки ctx_function (или, возможно, остановится в ожидании, когда завершится
    // экземпляр task
    return 0;
```
# Планирование задач

У каждой явно созданной задачи есть свой собственный стек, но и основной поток (в котором выполняется main или созданный std::thread) тоже имеет свой, только без явного экземпляра Task. Задачу (код+stack), которая выполняется на родном стеке потока, я называю thread bound, а Task с собственным стеком thread unbound (задача, корутина) (thread bound задачи нужны для того, чтобы иметь возможность переключать контекст с обычного пользовательского кода на Task, при этом нужно где-то сохранять контекст для переключения обратно, в результате, для обычного пользовательского кода, который работает с Task создается thread_local экземпляр Task, используемый для переключения контекстов). Thread bound Task (запущенная из main или std::thread) может выполняться только на своем родном потоке, а thread unbound на любом (созданном пользователем и специальном пуле потоков BgRunner). Сейчас планировщик сделан так, что потоки OS будут брать задачи из очереди активных, выполнять их код, но при очередном переключении проверяют, что их собственный контекст готов к продолжению выполнения и переключаются на него (т.е. для обычного потока, из которого выполняется main() или созданного пользователем через std::thread при переключении unbound задачи приоритетным будет переключиться на свою родную). Также есть специальный пул (сейчас в нем один поток) потоков BgRunner, которые выполняют задачи из очереди и возвращаются в свой родной контенст (цикл ожидания) только при отсутствии задач в очереди активных.

Итого, бывают три типа переключения контекста:

1. thread bound task (code in main or std::thread) -> unbound task (корутина) например, main запустил корутину или выполнил yield(), основной контекст ждет пока, работает корутина
2. unbound task (корутина) -> unbound task (корутина), корутина запустила другую корутину, решила переключить контекст по ожиданию или по yield
3. unbound task (корутина) -> thread bound task (code in main or std::thread), корутина решила переключить контекст, а к этому времени родной для этого потока код оказался готов к выполнению в результате произойдет переключение на него, потому что он в приоритете при смене контекста (пользовательский поток в первую очередь выполняет свой код)

Для возможности возвращения потока OS к нативному контексту создается thread_local переменная std::unique_ptr<Task>, которая описывает bound Task (она защищена unique_ptr, чтобы автоматически удаляться при завершении потока).

При постановке в очередь готовой корутины делается notify() для Futex, на котором ждут BgRunner, если в очереди готовых к выполнению задач что-то есть, будится один BgRunner. Таким образом, сейчас в main вызвать yield, то будет выполнена одна корутина из очереди (до момента ее первого переключения контекста), после чего сразу будет сделан переход обратно в main. Если же yield вызвать из корутины, то она будет поставлена в очередь активных задач, затем будет обработана вся (почти вся) очередь активных задач, после чего будет возврат к ней (она будет последней в очереди), при условии, что во время выполнения не произойдет переход к нативному контексту. BgRunner возвращается в цикл ожидания (его нативный контекст), когда очередь активных задач пуста.

# TODO

0. переименовать Awaitable в Synchronisator (?)
1. class Future to wait for data ready
2. Unit Tests
3. Asyncronous Networking (DNS resolver (этот будет асинхронным только каждый в своем потоке),
sockets)
4. собирать scontext для разных платформ (сейчас только Linux-x86_64-gcc,clang)

# License

LGPLv3+
